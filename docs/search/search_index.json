{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview Injector is lightweight and zero-overhead dependency injection library for JVM developers. It was carefully designed to make no-use of reflection by having all required meta-information computed at compile time. At runtime it performs only the necessary tasks required to instantiate classes and have its dependencies injected. Why Injector is different? \"Often in discussions about dependency injection, people mix the pattern with how it is supported by containers. There is plenty to criticize when it comes to many of these containers, but the core pattern is easy to appreciate: instead of letting objects assemble their own dependencies, classes state what dependencies they require from clients in order to be constructed and used .\" [ 1 ] Injector would be better described as small library with a single responsibility: inject dependencies on your objects. Despite of its small footprint (<7kb), it optimizes everything it requires to perform its tasks at compilation time, providing a zero-overhead runtime for your projects. Dependency injection in action Kotlin import injector.*; data class User ( val id : UUID = UUID . randomUUID () val name : String , val isPayingUser : Boolean ) @Singleton class UserPersistence { private val users = mutableMapOf < UUID , User > () fun save ( user : User ) { users . put ( user . id , user ); } fun loadAll (): Map < UUID , User > = users } @Singleton class UserService ( val persistence : UserPersistence ) { fun save ( user : User ){ if ( user . isPayingUser ) persistence . save ( user ) } } fun main () { val service = Injector . create (). instanceOf ( UserService . class ) val user = User ( \"joe@dinner.com\" , true ) service . save ( user ) } Java import injector.* ; import java.util.* ; class User { final UUID id = UUID . randomUUID (); final String name ; final Boolean isPayingUser ; User ( String name , Boolean isPayingUser ){ this . name = name ; this . isPayingUser = isPayingUser ; } } @Singleton class UserPersistence { private final Map < UUID , User > users = new HashMap <> (); void save ( User user ) { users . put ( user . id , user ); } } @Singleton class UserService { final UserPersistence persistence ; UserService ( UserPersistence persistence ){ this . persistence = persistence ; } void save ( User user ){ if ( user . isPayingUser ) persistence . save ( user ); } } class Main { public static void main ( String [] args ) { UserService service = Injector . create (). instanceOf ( UserService . class ); User user = new User ( \"joe@dinner.com\" , true ); service . save ( user ); } } License Injector is release under Apache License 2 terms.","title":"Overview"},{"location":"#overview","text":"Injector is lightweight and zero-overhead dependency injection library for JVM developers. It was carefully designed to make no-use of reflection by having all required meta-information computed at compile time. At runtime it performs only the necessary tasks required to instantiate classes and have its dependencies injected.","title":"Overview"},{"location":"#why-injector-is-different","text":"\"Often in discussions about dependency injection, people mix the pattern with how it is supported by containers. There is plenty to criticize when it comes to many of these containers, but the core pattern is easy to appreciate: instead of letting objects assemble their own dependencies, classes state what dependencies they require from clients in order to be constructed and used .\" [ 1 ] Injector would be better described as small library with a single responsibility: inject dependencies on your objects. Despite of its small footprint (<7kb), it optimizes everything it requires to perform its tasks at compilation time, providing a zero-overhead runtime for your projects.","title":"Why Injector is different?"},{"location":"#dependency-injection-in-action","text":"Kotlin import injector.*; data class User ( val id : UUID = UUID . randomUUID () val name : String , val isPayingUser : Boolean ) @Singleton class UserPersistence { private val users = mutableMapOf < UUID , User > () fun save ( user : User ) { users . put ( user . id , user ); } fun loadAll (): Map < UUID , User > = users } @Singleton class UserService ( val persistence : UserPersistence ) { fun save ( user : User ){ if ( user . isPayingUser ) persistence . save ( user ) } } fun main () { val service = Injector . create (). instanceOf ( UserService . class ) val user = User ( \"joe@dinner.com\" , true ) service . save ( user ) } Java import injector.* ; import java.util.* ; class User { final UUID id = UUID . randomUUID (); final String name ; final Boolean isPayingUser ; User ( String name , Boolean isPayingUser ){ this . name = name ; this . isPayingUser = isPayingUser ; } } @Singleton class UserPersistence { private final Map < UUID , User > users = new HashMap <> (); void save ( User user ) { users . put ( user . id , user ); } } @Singleton class UserService { final UserPersistence persistence ; UserService ( UserPersistence persistence ){ this . persistence = persistence ; } void save ( User user ){ if ( user . isPayingUser ) persistence . save ( user ); } } class Main { public static void main ( String [] args ) { UserService service = Injector . create (). instanceOf ( UserService . class ); User user = new User ( \"joe@dinner.com\" , true ); service . save ( user ); } }","title":"Dependency injection in action"},{"location":"#license","text":"Injector is release under Apache License 2 terms.","title":"License"},{"location":"basics/","text":"Injecting Dependencies Injector Context Every project should have at least one Injector Context instantiated. It is responsible for holding objects references so you can ask for them anytime later. Kotlin val injector = Injector . creator () Java Injector injector = Injector . creator (); Constructor Injection In order to keep dependency injection experience as close as possible to vanilla java , Injector opted for constructor injection as its main (and only) injection mechanism. That's a good strategy towards immutability and other clean-code good practices. Making classes injectable Injector will allow developers to expose objects in two ways: Singleton - classes exposed like this will have only one instance of its type registered in the Injection Context. To expose singleton classes you should annotated them with the injector.Singleton annotation. Regular classes - as the name states this isn't a special type but a class in which a new instance will be created every time it should be injected. To expose normal classes you should annotated them with the injector.New annotation. Kotlin @Singleton class SingletonServiceA @New class RegularServiceB @Singleton class SingletonServiceB ( val serviceA : SingletonServiceA , val serviceB : RegularServiceB ) @Singleton class SingletonServiceC ( val serviceA : SingletonServiceA , val serviceB : RegularServiceB ) Java @Singleton class SingletonServiceA {} @New class RegularServiceB {} @Singleton class SingletonServiceB { final SingletonServiceA serviceA ; final RegularServiceB serviceB ; SingletonServiceB ( SingletonServiceA serviceA , RegularServiceB serviceB ) { this . serviceA = serviceA ; this . serviceB = serviceB ; } } @Singleton class SingletonServiceC { final SingletonServiceA serviceA ; final RegularServiceB serviceB ; SingletonServiceC ( SingletonServiceA serviceA , RegularServiceB serviceB ) { this . serviceA = serviceA ; this . serviceB = serviceB ; } } If we instantiate an Injector Context, we're going to have one instance of SingletonServiceA, SingletonServiceB and SingletonServiceC - as they are singletons - and two instances of RegularServiceB - as it is a regular class. Retrieving your injectable service Once you expose your services you'll be able to ask the Injector Context for instances and it will take care of instantiate them and return the instance as you need. Kotlin val injector = Injector . creator () val serviceC = injector . instanceOf ( SingletonServiceC . class ) Java Injector injector = Injector . creator (); SingletonServiceC serviceC = injector . instanceOf ( SingletonServiceC . class ); Injector will respect the aforementioned rules regarding singletons, thus anytime you ask for an instance of SingletonServiceC you're going to receive the same instance. Note though that you're going to receive different instances if you ask for an instance of RegularServiceB .","title":"Injecting Dependencies"},{"location":"basics/#injecting-dependencies","text":"","title":"Injecting Dependencies"},{"location":"basics/#injector-context","text":"Every project should have at least one Injector Context instantiated. It is responsible for holding objects references so you can ask for them anytime later. Kotlin val injector = Injector . creator () Java Injector injector = Injector . creator ();","title":"Injector Context"},{"location":"basics/#constructor-injection","text":"In order to keep dependency injection experience as close as possible to vanilla java , Injector opted for constructor injection as its main (and only) injection mechanism. That's a good strategy towards immutability and other clean-code good practices.","title":"Constructor Injection"},{"location":"basics/#making-classes-injectable","text":"Injector will allow developers to expose objects in two ways: Singleton - classes exposed like this will have only one instance of its type registered in the Injection Context. To expose singleton classes you should annotated them with the injector.Singleton annotation. Regular classes - as the name states this isn't a special type but a class in which a new instance will be created every time it should be injected. To expose normal classes you should annotated them with the injector.New annotation. Kotlin @Singleton class SingletonServiceA @New class RegularServiceB @Singleton class SingletonServiceB ( val serviceA : SingletonServiceA , val serviceB : RegularServiceB ) @Singleton class SingletonServiceC ( val serviceA : SingletonServiceA , val serviceB : RegularServiceB ) Java @Singleton class SingletonServiceA {} @New class RegularServiceB {} @Singleton class SingletonServiceB { final SingletonServiceA serviceA ; final RegularServiceB serviceB ; SingletonServiceB ( SingletonServiceA serviceA , RegularServiceB serviceB ) { this . serviceA = serviceA ; this . serviceB = serviceB ; } } @Singleton class SingletonServiceC { final SingletonServiceA serviceA ; final RegularServiceB serviceB ; SingletonServiceC ( SingletonServiceA serviceA , RegularServiceB serviceB ) { this . serviceA = serviceA ; this . serviceB = serviceB ; } } If we instantiate an Injector Context, we're going to have one instance of SingletonServiceA, SingletonServiceB and SingletonServiceC - as they are singletons - and two instances of RegularServiceB - as it is a regular class.","title":"Making classes injectable"},{"location":"basics/#retrieving-your-injectable-service","text":"Once you expose your services you'll be able to ask the Injector Context for instances and it will take care of instantiate them and return the instance as you need. Kotlin val injector = Injector . creator () val serviceC = injector . instanceOf ( SingletonServiceC . class ) Java Injector injector = Injector . creator (); SingletonServiceC serviceC = injector . instanceOf ( SingletonServiceC . class ); Injector will respect the aforementioned rules regarding singletons, thus anytime you ask for an instance of SingletonServiceC you're going to receive the same instance. Note though that you're going to receive different instances if you ask for an instance of RegularServiceB .","title":"Retrieving your injectable service"},{"location":"config/","text":"Configuring your project Injector makes heavy use of annotation processor, so make sure you have properly configured you project to support it. All generated assets are compatible with Java version 8 or superior. Important Kotlin users should have kapt properly configured in order to have injector working effectively. Import the libraries Injector is made by two small libraries: injector-core - [ required at runtime ] contains everything required to run an injector-based application. injector-processor - [ optional ] the annotation processor library responsible for generating factories and metadata required to perform the dependence injection. All of them are available in Maven Central and you can import on your Gradle/Maven project as below described. Gradle (Kotlin) repositories { mavenCentral () } dependencies { implementation ( platform ( \"io.skullabs.injector:injector-bom:1.5.0\" )) implementation ( \"io.skullabs.injector:injector-core\" ) compileOnly ( \"io.skullabs.injector:injector-processor\" ) } Maven (pom.kts) dependencies { compile ( \"io.skullabs.injector:injector-core\" ) provided ( \"io.skullabs.injector:injector-processor\" ) } dependencyManagement { dependencies { import ( \"io.skullabs.injector:injector-bom:1.5.0\" ) } } Maven (pom.xml) <dependencies> <dependency> <groupId> io.skullabs.injector </groupId> <artifactId> injector-core </artifactId> </dependency> <dependency> <groupId> io.skullabs.injector </groupId> <artifactId> injector-processor </artifactId> </dependency> </dependencies> <dependencyManagement> <dependency> <groupId> io.skullabs.injector </groupId> <artifactId> injector-bom </artifactId> <version> 1.5.0 </version> <scope> import </scope> <type> pom </type> </dependency> </dependencyManagement>","title":"Configuring your project"},{"location":"config/#configuring-your-project","text":"Injector makes heavy use of annotation processor, so make sure you have properly configured you project to support it. All generated assets are compatible with Java version 8 or superior. Important Kotlin users should have kapt properly configured in order to have injector working effectively.","title":"Configuring your project"},{"location":"config/#import-the-libraries","text":"Injector is made by two small libraries: injector-core - [ required at runtime ] contains everything required to run an injector-based application. injector-processor - [ optional ] the annotation processor library responsible for generating factories and metadata required to perform the dependence injection. All of them are available in Maven Central and you can import on your Gradle/Maven project as below described. Gradle (Kotlin) repositories { mavenCentral () } dependencies { implementation ( platform ( \"io.skullabs.injector:injector-bom:1.5.0\" )) implementation ( \"io.skullabs.injector:injector-core\" ) compileOnly ( \"io.skullabs.injector:injector-processor\" ) } Maven (pom.kts) dependencies { compile ( \"io.skullabs.injector:injector-core\" ) provided ( \"io.skullabs.injector:injector-processor\" ) } dependencyManagement { dependencies { import ( \"io.skullabs.injector:injector-bom:1.5.0\" ) } } Maven (pom.xml) <dependencies> <dependency> <groupId> io.skullabs.injector </groupId> <artifactId> injector-core </artifactId> </dependency> <dependency> <groupId> io.skullabs.injector </groupId> <artifactId> injector-processor </artifactId> </dependency> </dependencies> <dependencyManagement> <dependency> <groupId> io.skullabs.injector </groupId> <artifactId> injector-bom </artifactId> <version> 1.5.0 </version> <scope> import </scope> <type> pom </type> </dependency> </dependencyManagement>","title":"Import the libraries"}]}